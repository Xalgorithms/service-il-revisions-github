# Copyright (C) 2018 Don Kelly <karfai@gmail.com>
# Copyright (C) 2018 Hayk Pilosyan <hayk.pilos@gmail.com>

# This file is part of Interlibr, a functional component of an
# Internet of Rules (IoR).

# ACKNOWLEDGEMENTS
# Funds: Xalgorithms Foundation
# Collaborators: Don Kelly, Joseph Potvin and Bill Olders.

# This program is free software: you can redistribute it and/or
# modify it under the terms of the GNU Affero General Public License
# as published by the Free Software Foundation, either version 3 of
# the License, or (at your option) any later version.

# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# Affero General Public License for more details.

# You should have received a copy of the GNU Affero General Public
# License along with this program. If not, see
# <http://www.gnu.org/licenses/>.
# This file was generated by the `rspec --init` command. Conventionally, all
# specs live under a `spec` directory, which RSpec adds to the `$LOAD_PATH`.
# The generated `.rspec` file contains `--require spec_helper` which will cause
# this file to always be loaded, without a need to explicitly require it in any
# files.
#
require 'multi_json'

require_relative '../services/actions'

describe 'Application' do
  include Radish::Randomness
  
  def last_response_json
    MultiJson.decode(last_response.body)
  end
  
  it 'should accept GET of /status' do
    get('/status')

    expect(last_response).to be_ok
    expect(last_response_json).to eql('status' => 'live')
  end
  
  it 'should accept POST of /actions' do
    payload = rand_document

    actions = double('Fake: actions')
    expect(Services::Actions).to receive(:instance).and_return(actions)
    expect(actions).to receive(:execute).with(payload)

    post('/actions', MultiJson.encode(payload))

    expect(last_response).to be_ok
    expect(last_response_json).to eql('status' => 'ok')    
  end

  it 'should fail nicely when the data is not JSON' do
    expect(Services::Actions).to_not receive(:instance)

    post('/actions', Faker::Lorem.paragraph)

    expect(last_response).to_not be_ok
    expect(last_response.status).to eql(500)
  end

  it 'should accept POST of /events when the github event is push' do
    exes = [
      {
        fn: 'branch.created',
        args: {
          branch: 'production',
          url: 'https://github.com/Xalgorithms/testing-rules.git',
          what: 'branch_created',
        },
      },
      {
        fn: 'branch.deleted',
        args: {
          branch: 'production',
          url: 'https://github.com/Xalgorithms/testing-rules.git',
          what: 'branch_removed',
        },
      },
      {
        fn: 'existing.files.updated',
        args: {
          branch: 'master',
          url: 'https://github.com/Xalgorithms/testing-rules.git',
          what: 'branch_updated',
          changes: [
            {
              previous_commit_id: 'cf83f6ace03c848b8d0312ba9a7b6b0d03d35ba9',
              commit_id: '295af90dfbb5d694bd5b91ecc6e3eca1b5ad2258',
              modified: [
                "org.xalgorithms.examples.a_plus_b/a_plus_b.rule",
                "org.xalgorithms.examples.a_plus_b/all_bs.table",
              ],
              committer: { name: 'Don Kelly', email: 'karfai@gmail.com' }
            },
          ],
        },
      },
      {
        fn: 'file.added',
        args: {
          branch: 'master',
          url: 'https://github.com/Xalgorithms/testing-rules.git',
          what: 'branch_updated',
          changes: [
            {
              previous_commit_id: '295af90dfbb5d694bd5b91ecc6e3eca1b5ad2258',
              commit_id: 'fbccee99d5bc373d43081fbe1ced4be90913e6f0',
              added: [
                "org.xalgorithms.examples.a_plus_b/more.json"
              ],
              committer: { name: 'Don Kelly', email: 'karfai@gmail.com' }
            },
          ],
        },
      },
      {
        fn: 'file.deleted',
        args: {
          branch: 'master',
          url: 'https://github.com/Xalgorithms/testing-rules.git',
          what: 'branch_updated',
          changes: [
            {
              previous_commit_id: 'fbccee99d5bc373d43081fbe1ced4be90913e6f0',
              commit_id: '4d11567bb9461e6404f3a2128022d3c5b329ac46',
              removed: [
                "org.xalgorithms.examples.a_plus_b/more.json"
              ],
              committer: { name: 'Don Kelly', email: 'karfai@gmail.com' }
            },
          ],
        },
      },
      {
        fn: 'multiple.commits',
        args: {
          branch: 'master',
          url: 'https://github.com/Xalgorithms/testing-rules.git',
          what: 'branch_updated',
          changes: [
            {
              previous_commit_id: 'cc6c383d4fa9b1fc72b5ec4b1fb078ac8d0ab5a8',
              commit_id: '5d37ad142d060b88d7c7f8fcb2b1389077a11db0',
              added: [
                "org.xalgorithms.examples.a_plus_b/more.json"
              ],
              committer: { name: 'Don Kelly', email: 'karfai@gmail.com' }
            },
            {
              previous_commit_id: '5d37ad142d060b88d7c7f8fcb2b1389077a11db0',
              commit_id: '585db8863d0aa00b945878d340ce55e0ecd38ac4',
              added: [
                "org.xalgorithms.examples.a_plus_b/even.more.json"
              ],
              removed: [
                "org.xalgorithms.examples.a_plus_b/more.json"
              ],
              committer: { name: 'Don Kelly', email: 'karfai@gmail.com' }
            },
          ],
        },
      },
      {
        fn: 'package.added',
        args: {
          branch: 'master',
          url: 'https://github.com/Xalgorithms/testing-rules.git',
          what: 'branch_updated',
          changes: [
            {
              previous_commit_id: '4d11567bb9461e6404f3a2128022d3c5b329ac46',
              commit_id: 'ed31826b864f2601ce11344d77cfdb7f2f9b1b84',
              added: [
                "org.xalgorithms.examples.a_plus_b2/a_plus_b.rule",
                "org.xalgorithms.examples.a_plus_b2/all_bs.json",
                "org.xalgorithms.examples.a_plus_b2/all_bs.table"
              ],
              committer: { name: 'Don Kelly', email: 'karfai@gmail.com' }
            },
          ],
        },
      },
    ]

    secret = '1234'
    exes.each do |ex|
      payload_s = IO.read("./spec/files/github/#{ex[:fn]}.json")
      sig = "sha1=#{OpenSSL::HMAC.hexdigest(OpenSSL::Digest.new('sha1'), secret, payload_s)}"
      ex_args = { 'name' => 'update', 'thing' => 'repository', 'args' => ex[:args].with_indifferent_access }

      actions = double('Fake: actions')
      expect(Services::Actions).to receive(:instance).and_return(actions)
      expect(actions).to receive(:execute).with(ex_args)

      ENV['GITHUB_SECRET'] = secret
      post('/events', payload_s, 'HTTP_X_HUB_SIGNATURE' => sig, 'HTTP_X_GITHUB_EVENT' => 'push')

      expect(last_response).to be_ok
      expect(last_response_json).to eql('status' => 'ok')
    end
  end

  it 'should not accept POST of /events when the event is not push' do
    payload = rand_document
    payload_s = MultiJson.encode(payload)
    secret = '1234'
    sig = "sha1=#{OpenSSL::HMAC.hexdigest(OpenSSL::Digest.new('sha1'), secret, payload_s)}"

    ex = {
      name: 'update',
      thing: 'repository',
      args: payload,
    }
    
    actions = double('Fake: actions')
    expect(Services::Actions).to_not receive(:instance)
    expect(actions).to_not receive(:execute)

    ENV['GITHUB_SECRET'] = secret
    rand_array_of_words.each do |event|
      post('/events', payload_s, 'HTTP_X_HUB_SIGNATURE' => sig, 'HTTP_X_GITHUB_EVENT' => event)

      expect(last_response).to_not be_ok
      expect(last_response.status).to eql(403)
      # can't test body in test (sintra wipes it out)
    end
  end

  it 'should not accept POST of /events when the signature is invalid or missing' do
    payload = rand_document
    payload_s = MultiJson.encode(payload)
    secret = '1234'
    sig = ''

    ex = {
      name: 'update',
      thing: 'repository',
      args: payload,
    }
    
    actions = double('Fake: actions')
    expect(Services::Actions).to_not receive(:instance)
    expect(actions).to_not receive(:execute)

    ENV['GITHUB_SECRET'] = secret
    post('/events', payload_s, 'HTTP_X_HUB_SIGNATURE' => sig)

    expect(last_response).to_not be_ok
    expect(last_response.status).to eql(403)
    
    post('/events', payload_s)
    
    expect(last_response).to_not be_ok
    expect(last_response.status).to eql(403)
  end
end
