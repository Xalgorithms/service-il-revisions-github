# Copyright (C) 2018 Don Kelly <karfai@gmail.com>
# Copyright (C) 2018 Hayk Pilosyan <hayk.pilos@gmail.com>

# This file is part of Interlibr, a functional component of an
# Internet of Rules (IoR).

# ACKNOWLEDGEMENTS
# Funds: Xalgorithms Foundation
# Collaborators: Don Kelly, Joseph Potvin and Bill Olders.

# This program is free software: you can redistribute it and/or
# modify it under the terms of the GNU Affero General Public License
# as published by the Free Software Foundation, either version 3 of
# the License, or (at your option) any later version.

# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# Affero General Public License for more details.

# You should have received a copy of the GNU Affero General Public
# License along with this program. If not, see
# <http://www.gnu.org/licenses/>.
# This file was generated by the `rspec --init` command. Conventionally, all
# specs live under a `spec` directory, which RSpec adds to the `$LOAD_PATH`.
# The generated `.rspec` file contains `--require spec_helper` which will cause
# this file to always be loaded, without a need to explicitly require it in any
# files.
#
require 'multi_json'

require_relative '../services/actions'

describe 'Application' do
  include Radish::Randomness
  
  def last_response_json
    MultiJson.decode(last_response.body)
  end
  
  it 'should accept GET of /status' do
    get('/status')

    expect(last_response).to be_ok
    expect(last_response_json).to eql('status' => 'live')
  end
  
  it 'should accept POST of /actions' do
    payload = rand_document

    actions = double('Fake: actions')
    expect(Services::Actions).to receive(:instance).and_return(actions)
    expect(actions).to receive(:execute).with(payload)

    post('/actions', MultiJson.encode(payload))

    expect(last_response).to be_ok
    expect(last_response_json).to eql('status' => 'ok')    
  end

  it 'should accept POST of /events when the github event is push' do
    payload = rand_document
    payload_s = MultiJson.encode(payload)
    secret = '1234'
    sig = "sha1=#{OpenSSL::HMAC.hexdigest(OpenSSL::Digest.new('sha1'), secret, payload_s)}"

    ex = {
      name: 'update',
      thing: 'repository',
      args: payload,
    }
    
    actions = double('Fake: actions')
    expect(Services::Actions).to receive(:instance).and_return(actions)
    expect(actions).to receive(:execute).with(ex)

    ENV['GITHUB_SECRET'] = secret
    post('/events', payload_s, 'HTTP_X_HUB_SIGNATURE' => sig, 'HTTP_X_GITHUB_EVENT' => 'push')

    expect(last_response).to be_ok
    expect(last_response_json).to eql('status' => 'ok')        
  end

  it 'should not accept POST of /events when the event is not push' do
    payload = rand_document
    payload_s = MultiJson.encode(payload)
    secret = '1234'
    sig = "sha1=#{OpenSSL::HMAC.hexdigest(OpenSSL::Digest.new('sha1'), secret, payload_s)}"

    ex = {
      name: 'update',
      thing: 'repository',
      args: payload,
    }
    
    actions = double('Fake: actions')
    expect(Services::Actions).to_not receive(:instance)
    expect(actions).to_not receive(:execute)

    ENV['GITHUB_SECRET'] = secret
    rand_array_of_words.each do |event|
      post('/events', payload_s, 'HTTP_X_HUB_SIGNATURE' => sig, 'HTTP_X_GITHUB_EVENT' => event)

      expect(last_response).to_not be_ok
      expect(last_response.status).to eql(403)
    end
  end

  it 'should not accept POST of /events when the signature is invalid or missing' do
    payload = rand_document
    payload_s = MultiJson.encode(payload)
    secret = '1234'
    sig = ''

    ex = {
      name: 'update',
      thing: 'repository',
      args: payload,
    }
    
    actions = double('Fake: actions')
    expect(Services::Actions).to_not receive(:instance)
    expect(actions).to_not receive(:execute)

    ENV['GITHUB_SECRET'] = secret
    post('/events', payload_s, 'HTTP_X_HUB_SIGNATURE' => sig)

    expect(last_response).to_not be_ok
    expect(last_response.status).to eql(403)
    
    post('/events', payload_s)
    
    expect(last_response).to_not be_ok
    expect(last_response.status).to eql(403)
  end
end
